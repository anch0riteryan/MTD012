#include <sam.h>
#include <nvm.h>

#define GCLK_ID_MAIN 0
#define GCLK_ID_96MHZ 1
#define GCLK_ID_32KHZ 2
#define GCLK_ID_8MHZ 8

void init_pinout () {
	// LED
	PORT_REGS->GROUP[0].PORT_DIRSET = 1 << 28;

	// SER3 UART
	PORT_REGS->GROUP[0].PORT_PMUX[12] = PORT_PMUX_PMUXE_C | PORT_PMUX_PMUXO_C;
	PORT_REGS->GROUP[0].PORT_PINCFG[24] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[25] = PORT_PINCFG_PMUXEN (1);

	// RADIO
	PORT_REGS->GROUP[1].PORT_PMUX[4] = PORT_PMUX_PMUXE_A;
	PORT_REGS->GROUP[1].PORT_PINCFG[8] = PORT_PINCFG_PMUXEN (1);

	// FAN PWM, PULSE
	PORT_REGS->GROUP[0].PORT_PMUX[7] = PORT_PMUX_PMUXE_E;
	PORT_REGS->GROUP[0].PORT_PINCFG[14] = PORT_PINCFG_PMUXEN (1);

	PORT_REGS->GROUP[0].PORT_DIRCLR = 1 << 15;
	PORT_REGS->GROUP[0].PORT_OUTSET = 1 << 15;
	PORT_REGS->GROUP[0].PORT_PINCFG[15] = PORT_PINCFG_INEN (1) | PORT_PINCFG_PULLEN (1);

	// BLDC PWM
	PORT_REGS->GROUP[0].PORT_PMUX[ 8] = PORT_PMUX_PMUXE_F | PORT_PMUX_PMUXO_F;
	PORT_REGS->GROUP[0].PORT_PMUX[ 9] = PORT_PMUX_PMUXE_F | PORT_PMUX_PMUXO_F;
	PORT_REGS->GROUP[0].PORT_PMUX[11] = PORT_PMUX_PMUXE_F | PORT_PMUX_PMUXO_F;
	PORT_REGS->GROUP[0].PORT_PINCFG[16] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[17] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[18] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[19] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[22] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[23] = PORT_PINCFG_PMUXEN (1);

	// analog comparator
	PORT_REGS->GROUP[0].PORT_PMUX[2] = PORT_PMUX_PMUXE_B | PORT_PMUX_PMUXE_B;
	PORT_REGS->GROUP[0].PORT_PMUX[3] = PORT_PMUX_PMUXE_B | PORT_PMUX_PMUXE_B;
	PORT_REGS->GROUP[0].PORT_PINCFG[4] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[5] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[6] = PORT_PINCFG_PMUXEN (1);
	PORT_REGS->GROUP[0].PORT_PINCFG[7] = PORT_PINCFG_PMUXEN (1);

}

void init_clock () {
	NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS_DUAL; //NVMCTRL_CTRLB_RWS (NVMCTRL_CTRLB_RWS_DUAL_Val);

	OSC32KCTRL_REGS->OSC32KCTRL_OSCULP32K =
		OSC32KCTRL_OSCULP32K_WRTLOCK (1);
		//OSC32KCTRL_OSCULP32K_CALIB ((uint32_t) nvm.software_calibration.bit.OSC32K_CAL);

	GCLK_REGS->GCLK_CTRLA = GCLK_CTRLA_SWRST (1);
	while (GCLK_REGS->GCLK_SYNCBUSY & GCLK_CTRLA_SWRST (1));

	// internal osc. set to 8MHz
	OSCCTRL_REGS->OSCCTRL_OSC48MDIV  = OSCCTRL_OSC48MDIV_DIV_DIV5; //8MHz
	OSCCTRL_REGS->OSCCTRL_CAL48M = nvm.software_calibration.bit.CAL48M_5V;
	OSCCTRL_REGS->OSCCTRL_OSC48MCTRL = OSCCTRL_OSC48MCTRL_ONDEMAND (1) | OSCCTRL_OSC48MCTRL_ENABLE (1);
	while ((OSCCTRL_REGS->OSCCTRL_STATUS & OSCCTRL_STATUS_OSC48MRDY (1)) == 0);

	// startup external 32k crystal
	OSC32KCTRL_REGS->OSC32KCTRL_XOSC32K = 
		OSC32KCTRL_XOSC32K_WRTLOCK (0) |
		OSC32KCTRL_XOSC32K_STARTUP_CYCLE2048 |
		OSC32KCTRL_XOSC32K_ONDEMAND (0) |
		OSC32KCTRL_XOSC32K_EN1K (0) |
		OSC32KCTRL_XOSC32K_EN32K (1) |
		OSC32KCTRL_XOSC32K_XTALEN (1) |
		OSC32KCTRL_XOSC32K_ENABLE (1);
	while ((OSC32KCTRL_REGS->OSC32KCTRL_STATUS & OSC32KCTRL_STATUS_XOSC32KRDY_Msk) == 0);

	// 32khz GCLK
	GCLK_REGS->GCLK_GENCTRL[GCLK_ID_32KHZ] =
		GCLK_GENCTRL_DIV (0) |
		GCLK_GENCTRL_DIVSEL_DIV1 |
		GCLK_GENCTRL_OE (0) |
		GCLK_GENCTRL_IDC (1) |
		GCLK_GENCTRL_GENEN (1) |
		GCLK_GENCTRL_SRC_XOSC32K;
	while (GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL (GCLK_ID_32KHZ));
	
	// FDPLL clock setup
	GCLK_REGS->GCLK_PCHCTRL[OSCCTRL_GCLK_ID_FDPLL32K] =
		GCLK_PCHCTRL_WRTLOCK (1) |
		GCLK_PCHCTRL_CHEN (1) |
		GCLK_PCHCTRL_GEN (GCLK_ID_32KHZ);
	GCLK_REGS->GCLK_PCHCTRL[OSCCTRL_GCLK_ID_FDPLL] =
		GCLK_PCHCTRL_WRTLOCK (1) |
		GCLK_PCHCTRL_CHEN (1) |
		GCLK_PCHCTRL_GEN (GCLK_ID_32KHZ);

	//
	// Finput = 32.768KHz; Fout = 96MHz
	// Fout = Fin x (LDR + 1 + (LDRFRAC / 16)) x (1 / 2^PRESC)
	// 96MHz / 32.768KHz = 2929.6875
	// LDRFRAC = 0.6875 x 16 = 11
	// LDR = 2929 - 1 = 2928
	//
	OSCCTRL_REGS->OSCCTRL_DPLLRATIO =
		OSCCTRL_DPLLRATIO_LDR (2928) |
		OSCCTRL_DPLLRATIO_LDRFRAC (11);
	while (OSCCTRL_REGS->OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO (1));
	
	OSCCTRL_REGS->OSCCTRL_DPLLCTRLB = 
		OSCCTRL_DPLLCTRLB_REFCLK_GCLK_Val | 
		OSCCTRL_DPLLCTRLB_WUF (0) |
		OSCCTRL_DPLLCTRLB_LPEN (0) |
		OSCCTRL_DPLLCTRLB_FILTER (1) |
		OSCCTRL_DPLLCTRLB_LBYPASS (0) |
		OSCCTRL_DPLLCTRLB_LTIME_10MS |
		OSCCTRL_DPLLCTRLB_DIV (0);
	
	OSCCTRL_REGS->OSCCTRL_DPLLCTRLA =
		OSCCTRL_DPLLCTRLA_ONDEMAND (0) |
		OSCCTRL_DPLLCTRLA_ENABLE (1);
	while ((OSCCTRL_REGS->OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_ENABLE (1)) == 0);

	while (
		((OSCCTRL_REGS->OSCCTRL_DPLLSTATUS & OSCCTRL_DPLLSTATUS_CLKRDY (1)) == 0) |
		((OSCCTRL_REGS->OSCCTRL_DPLLSTATUS & OSCCTRL_DPLLSTATUS_LOCK (1)) == 0)
	);

	// GCLK 8MHz
	GCLK_REGS->GCLK_GENCTRL[GCLK_ID_8MHZ] =
		GCLK_GENCTRL_DIV (12) | // 96MHz / 12 = 8MHz
		GCLK_GENCTRL_DIVSEL_DIV1 |
		GCLK_GENCTRL_OE (0) |
		GCLK_GENCTRL_IDC (1) |
		GCLK_GENCTRL_GENEN (1) |
		GCLK_GENCTRL_SRC_DPLL96M;
	while (GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL (GCLK_ID_8MHZ));

	// GCLK 96MHz
	GCLK_REGS->GCLK_GENCTRL[GCLK_ID_96MHZ] =
		GCLK_GENCTRL_DIV (0) |
		GCLK_GENCTRL_DIVSEL_DIV1 |
		GCLK_GENCTRL_OE (0) |
		GCLK_GENCTRL_IDC (1) |
		GCLK_GENCTRL_GENEN (1) |
		GCLK_GENCTRL_SRC_DPLL96M;
	while (GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL (GCLK_ID_96MHZ));

	// GCLK 2.4MHZ
	GCLK_REGS->GCLK_GENCTRL[3] =
		GCLK_GENCTRL_DIV (40) |
		GCLK_GENCTRL_DIVSEL_DIV1 |
		GCLK_GENCTRL_OE (0) |
		GCLK_GENCTRL_IDC (1) |
		GCLK_GENCTRL_GENEN (1) |
		GCLK_GENCTRL_SRC_DPLL96M;
	while (GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL (GCLK_ID_96MHZ));

	// GCLK 48MHz Main
	GCLK_REGS->GCLK_GENCTRL[GCLK_ID_MAIN] =
		GCLK_GENCTRL_DIV (2) | // 96MHz / 2 = 48MHz
		GCLK_GENCTRL_DIVSEL_DIV1 |
		GCLK_GENCTRL_OE (0) |
		GCLK_GENCTRL_IDC (1) |
		GCLK_GENCTRL_GENEN (1) |
		GCLK_GENCTRL_SRC_DPLL96M;
	while (GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL (GCLK_ID_MAIN));
}

void init_eic () {
	GCLK_REGS->GCLK_PCHCTRL[EIC_GCLK_ID] =
		GCLK_PCHCTRL_WRTLOCK (1) |
		GCLK_PCHCTRL_GEN (0) |
		GCLK_PCHCTRL_CHEN (1);

	EIC_REGS->EIC_CTRLA = EIC_CTRLA_SWRST (1);
	while (EIC_REGS->EIC_CTRLA & EIC_CTRLA_SWRST (1));

	EIC_REGS->EIC_ASYNCH = EIC_ASYNCH_ASYNCH (0xFFFF);

	//RADIO PPM EVENT (EXINT 8)
	//FAN-RPM SENSOR PULSE (EXINT 15)
	EIC_REGS->EIC_CONFIG[1] = EIC_CONFIG_SENSE0_HIGH;

	EIC_REGS->EIC_INTFLAG = EIC_INTFLAG_EXTINT (0xFFFF);
	EIC_REGS->EIC_INTENSET = 0;
	EIC_REGS->EIC_EVCTRL = EIC_EVCTRL_EXTINTEO (1 << 8);// | EIC_EVCTRL_EXTINTEO (1 << 15);

	EIC_REGS->EIC_CTRLA = EIC_CTRLA_CKSEL_CLK_GCLK | EIC_CTRLA_ENABLE (1);
	while (EIC_REGS->EIC_SYNCBUSY & EIC_SYNCBUSY_ENABLE (1));
	
}

void init_evsys () {
	MCLK_REGS->MCLK_APBCMASK |= MCLK_APBCMASK_EVSYS (1);

	EVSYS_REGS->EVSYS_CTRLA = EVSYS_CTRLA_SWRST (1);
	while (EVSYS_REGS->EVSYS_CTRLA & EVSYS_CTRLA_SWRST (1));

	// RADIO RETRIGGER
	GCLK_REGS->GCLK_PCHCTRL[EVSYS_GCLK_ID_0] =
		GCLK_PCHCTRL_WRTLOCK (1) |
		GCLK_PCHCTRL_GEN (0) |
		GCLK_PCHCTRL_CHEN (1);
	
	EVSYS_REGS->EVSYS_CHANNEL[0] = 
		EVSYS_CHANNEL_EVGEN (EVENT_ID_GEN_EIC_EXTINT_8) |
		EVSYS_CHANNEL_PATH_SYNCHRONOUS |
		EVSYS_CHANNEL_EDGSEL_RISING_EDGE |
		EVSYS_CHANNEL_RUNSTDBY (0) |
		EVSYS_CHANNEL_ONDEMAND (0);
	EVSYS_REGS->EVSYS_USER[EVENT_ID_USER_TCC2_EV_0] = EVSYS_USER_CHANNEL (1); // EVSYS CH-0

	// RADIO CAPTURE
	GCLK_REGS->GCLK_PCHCTRL[EVSYS_GCLK_ID_1] =
		GCLK_PCHCTRL_WRTLOCK (1) |
		GCLK_PCHCTRL_GEN (0) |
		GCLK_PCHCTRL_CHEN (1);
	
	EVSYS_REGS->EVSYS_CHANNEL[1] = 
		EVSYS_CHANNEL_EVGEN (EVENT_ID_GEN_EIC_EXTINT_8) |
		EVSYS_CHANNEL_PATH_SYNCHRONOUS |
		EVSYS_CHANNEL_EDGSEL_FALLING_EDGE |
		EVSYS_CHANNEL_RUNSTDBY (0) |
		EVSYS_CHANNEL_ONDEMAND (0);
	EVSYS_REGS->EVSYS_USER[EVENT_ID_USER_TCC2_MC_0] = EVSYS_USER_CHANNEL (2); // EVSYS CH-1
}
